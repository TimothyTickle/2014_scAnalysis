```{r setup, include=FALSE}
opts_chunk$set(cache=TRUE)
```

Single-cell RNA-Seq Analysis
========================================================
author: Timothy Tickle and Brian Haas
css: single_cell_analysis.css
date: October 10, 2016

Before We Get Started
===

- Single-cell analysis is new.
  - Give you a feel for the data.
  - Give you some options to explore.
  - These techniques will grow as the field does.

Before We Get Started
===

- This is VERY hands on.
  - Much can be applied to other analyses.
  - Strengthen those R ninja skills!
  - If you need, cut and pasting is available (cut_and_paste.txt).
  - There will many cute corgi pics.

---

![ninja corgis](images/corgis/ninja_corgi.jpeg)

What We Will Attempt to Cover
===

### Day 1  
__Morning:__ Overview of laboratory prep and sequence analysis.  
__Afternoon:__ Characteristics of expression data and QC.  

### Day 2  
__Morning:__ Plotting Single Cell RNA-Seq data.  
__Afternoon:__ Evaluating and defining cell populations.  

Welcome to day 1
===

- Overview of assays (SmartSeq2, Dropseq, 10X).
- Overview of sequence data (SmartSeq2, Dropseq, 10X).
- Overview of Dropseq sequence analysis pipeline.
- Overview of 10X sequence analysis pipeline.
- Sequence level quality control.
- What does single cell expression data look like and why?
- Introduction to RStudio.
- Initial data exploration.
- Quality control for expression matrices.
- Filtering genes and samples.
- Considerations in data analysis when using UMIs.
- Why normalize gene expression and common types of normalization?
- Using Scone for normalization.

Overview of assays (SmartSeq2, Dropseq, 10X)
===

![scientist](images/corgis/scientist.jpg)

SmartSeq2
===

![smartseq_paper](images/smartseq_paper.png)

---

![smartseq_protocols](images/smartseq_protocols.png)

SmartSeq2: Description
===


SmartSeq2: Assay Overview
===

![smartseq2_seq](images/smart_seq2.jpg)

SmartSeq2: Equipment
===

![sequencer](images/nextseq-large.jpg)

---

![plate](images/plate.jpg)

SmartSeq2: Pointers
===

- Plate-based methods get lysed in wells and so do not leak.

Dropseq
===

![drop_seq](images/dropseq_paper.png)  

Dropseq: Description
===

- Droplet-based using microfluidics

Dropseq: Assay Overview
===

[Drop Seq Video Abstract](http://www.sciencedirect.com/science/article/pii/S0092867415005498)

Dropseq: UMI Construction
===

![drop_umi](images/dropseq_assay_umi.png)

Dropseq: Assay Overview
===

![dropseq_assay_1](images/dropseq_assay_1.png)

Dropseq: Microfluidics
===

![drop_beads](images/dropseq_drops.gif)

Dropseq: Equipment
===

![dropseq_eq](images/drop_seq_equipment.jpeg)

---

![dropseq_single](images/dropseq_fluidics.png)
![dropseq_large](images/Drop-seq-chip-large.jpg)

Dropseq: Pointers
===

- Droplet-based assays can have leaky RNA.
- Before library generation wash off any medium (inhibits library generation).
- Adding PBS and BSA (0.05-0.01%) can protect the cell.
  - Too much produces a residue making harvesting the beads difficult.
- Filter all reagent with a 80 micron strainer before microfluidics.
- Some purchased devices add a hydrophobic coating.
  - Can deteriorate (2 months at best).
  - Recoating does work (in-house).

10X
===

![10x_paper](images/10X_paper.png)


10X: Description
===

- Droplet-based, 3' mRNA
- Standardized instrumentation and reagents
- Less processing time
- More high-throughput 1-6K cell for sample
- Up to 50% capture rate.

10X: Assay Overview
===

![10x_assay](images/10X_wet.png)

10X: Sequences
===

![10x_sequence](images/10X_wet_mol.png)

10X: Equipment
===

![10x_gem](images/10X_gem.png)

---

![10x_chip](images/dropseq_fluidics_big.png)

Comparing Assays
===

![comparing_paper](images/compare_power_paper.png)

Comparing Assays
===

![comparing_assays](images/compare_assays.png)

Comparing Assays
===

![comparing_umi](images/compare_umi.png)

Comparing Assays
===

- Plate-based methods get lysed in wells and so do not leak.
  - Droplet-based can have leaky RNA.
- In Dropseq assays RT happends outside the droplets
  - Can use harsher lysis buffers.
  - 10X needs lysis buffers compatiable with the RT enzyme.

A Word on Sorting
===

- After disassociating cells cells can be performed.
- Know your cells, are they sticky, are they big?
  - Select an appropriate sized nozzle.
- Don't sort too quickly (1-2k cells per second or lower)
  - the slower the more time cells sit in lysis after sorting
    - 10 minutes max in lysis (some say 30 minutes)
- Callibrate speed of instrument with beads
  - Check alignment every 5-6 plates
- Afterwards spin down to make sure all cells are in lysis buffer
  - Flash freeze
- Chloe Villani on Sorting https://youtu.be/HiKY0eHDhIs

Sequence Pipeline Overviews
===

![corgi_can](images/corgis/corgi_can.jpg)

Smartseq2: Pipeline Overview
===

![smart_seq_seq](images/population_rnaseq.png)

---

![normal_align](images/aligncount.png)

Dropseq: Pipeline Overview
===

![drop_seq_seq](images/dropseq_rnaseq.png)

Dropseq: Further Help
===

![drop_seq_web](images/drop_seq_web.png)

10X: Pipeline Overview
===

![10_seq](images/10x_rnaseq.png)

10X: Further Help
===

![10_help](images/10x_web.png)

Sequence level quality control
===

![seq_qc](images/population_rnaseq_qc.png)

Section Summary
===

- Single-cell RNA-Seq is a diverse ecosystem of assays.
  - Each assay has pros and cons.
- Sequences derived from these assays are complex and vary.
- Different pipelines are needed to address different sequence formats.
  - Common steps like aligning, QC, and reads counting are in common.

What does single cell expression data look like and why?
===

![driving](images/corgis/driving_corgi.jpg)

We Start with a Matrix of Expression
===

![starting_matrix](images/starting_matrix.png)

Genes Have Different Distributions
===
class:small-code

![genes_log_normal](images/scdistributions_log_normal.png)

Genes Have Different Distributions
===
class:small-code

![genes_bimodal](images/scdistributions_bimodal.png)

Genes Have Different Distributions
===
class:small-code

![genes_zeroinfl](images/scdistributions_zeroinfl.png)

Genes Have Different Distributions
===
class:small-code

![genes_noise](images/scdistributions_noise.png)

Genes Have Different Distributions
===
class:small-code

![professor corgi](images/scdistributions_all.png)

Underlying Biology
===

Zero inflation.
- Drop-out event during reverse-transcription.
- Genes with more expression have less zeros.
- Complexity varies.

Transcription stochasticity.
- Transcription bursting.
- Coordinated transcription of multigene networks.
- Overdispersed counts.

Higher Resolution.
- More sources of signal
  - Cell cycle

---

![scde_bio](images/scde_bio.png)

Considerations in data analysis when using UMIs
===

 Points
 - Same sequence aligned to the same gene
 - Show example of UMI collapse
 - Can filter more conservatively when collapsing by UMI

Summary of the Data
===

- We are still understanding scData and how to apply it.
  - Data can be NOT normal.
  - Data can be Zero-inflated.
  - Data can be very noisey.
  - Cells vary in library complexity.
- Keeping these characteristics in analysis assumptions.

Introduction to RStudio
===

![bed](images/corgis/dogbutt.jpg)

RStudio Integrative Development Environment
===

![rstudio_overview](images/Rstudio_overview.png)

Initial data exploration
===

![professor corgi](images/corgis/professor_corgi.jpg)

Seurat
===

![suerat](images/seurat_pubs.png)

Logistics
===
class:small-code

```{r, eval=TRUE, echo=TRUE, tidy=FALSE}
# Load libraries
library(Seurat) # Single cell General Analysis
library(dplyr) # Dataframe manipulation
library(Matrix) # Sparse matrices
library(useful) # Corner function
library(vioplot) # Violin pots
library(scater) # Single Cell QC
```

Representing Sparse Matrices
===

```{r, eval=TRUE, echo=TRUE, tidy=FALSE}
# Load 10X data
pbmc.10X <- Read10X("./data/filtered_gene_bc_matrices/hg19")

# Memory use as a sparse matrix
object.size(pbmc.10X)

# Memory use as a dense matrix
# 18 X more
object.size(as.matrix(pbmc.10X))
```

How are Sparse Representations Made?
===

- Sparse Matrix: A matrix where most of the elements are 0.
- Dense Matrix: A matrix where most elements are not 0.
- Underlying structure is a coordinate list.

2D Arrays vs Coordinate List
===

![sparse](images/sparseMatrices.png)

Create a Seurat Object
===

```{r, eval=TRUE, echo=TRUE, tidy=FALSE}
# Expected raw counts (non-normalized data)
# Can give log transformed data but do not transform in setup method
pbmc.seurat <- new("seurat", raw.data=pbmc.10X)
```

What is in a Seurat Object?
===

```{r, eval=FALSE, echo=TRUE, tidy=FALSE}
# Display the internal pieces of the Seurat Object
slotNames(pbmc.seurat)
```

What is in a Seurat Object?
===

```{r, eval=TRUE, echo=FALSE, tidy=FALSE}
# Display the internal pieces of the Seurat Object
slotNames(pbmc.seurat)
```

What is in a Seurat Object?
===

Raw sparse matrix

```{r, eval=TRUE, echo=TRUE, tidy=FALSE}
head(pbmc.seurat@raw.data)
```

What is in a Seurat Object?
===

- __var.genes__ Variable genes across cells
- __data.info__ Misc info including complexity (nGene) 
- __cell.names__ Column (cell) names 
- __gene.names__ Row (gene) names

```{r, eval=TRUE, echo=TRUE, tidy=FALSE}
?seurat
```

Always Look at Your Data
===
class:midcenter

_**Hiding within those mounds of data is knowledge that could change the life of a patient, or change the world.**_  -â€“ Atul Butte

What are Our Genes?
===
class:small-code

```{r,eval=TRUE, echo=TRUE,tidy=TRUE}
# Gene names (row names)
head(row.names(pbmc.seurat@raw.data))
length(row.names(pbmc.seurat@raw.data))
```

What are Our Cells?
===
class:small-code

```{r,eval=TRUE, echo=TRUE,tidy=FALSE}
# Column names
# Sample / Cell names / Barcodes
head(colnames(pbmc.seurat@raw.data))
length(colnames(pbmc.seurat@raw.data))
```

How to Show Expression?
===
class:small-code

```{r,eval=FALSE, echo=TRUE,tidy=FALSE}
# Only the corner
# The full data will be too large to see
corner(as.matrix(pbmc.seurat@raw.data))
```

How to Show Expression?
===
class:small-code

```{r,eval=TRUE, echo=FALSE,tidy=FALSE}
# Only the corner
# The full data will be too large to see
corner(as.matrix(pbmc.seurat@raw.data))
```

How Many Expressed Genes (Complexity)?
===
class:small-code

```{r, eval=TRUE, echo=TRUE, tidy=TRUE}
# Plot genes per cell
# How many genes expressed per sample
complexity.per.cell <- apply(pbmc.seurat@raw.data, 2, function(x) sum(x>0))
# How much expression per cell.
expression.per.cell <- colMeans(pbmc.seurat@raw.data)
# Gene prevalence
gene.prevalence <- apply(pbmc.seurat@raw.data, 1, function(x) sum(x>0))
```

How Many Expressed Genes (Complexity)?
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
# Plot genes per cell
# How many genes expressed per sample
vioplot(complexity.per.cell)
stripchart(complexity.per.cell, add=TRUE, vertical=TRUE, method="jitter", jitter=0.3, pch=19)
abline(h=200, col="red")
abline(h=2500, col="blue")
```

Box Plots vs Violin Plots
===
class:small-code

**Boxplot:**  
Roboust representation of a distribution using quantiles

```{r, echo=FALSE, eval=TRUE, tidy=TRUE}
boxplot(complexity.per.cell)
```

---

**Violin Plot:**  
Box plot with kernel density plot mirrored on sides.

```{r, echo=FALSE, eval=TRUE, tidy=TRUE}
vioplot(complexity.per.cell)
```

How Many Expressed Genes (Complexity)?
===
class:small-code

Complexity of all samples in a study.  
```{r, eval=TRUE, echo=FALSE, tidy=TRUE}
# Plot genes per cell
# How many genes expressed per sample
vioplot(complexity.per.cell)
stripchart(complexity.per.cell, add=TRUE, vertical=TRUE, method="jitter", jitter=0.3, pch=19)
abline(h=200, col="red")
abline(h=2500, col="blue")
```

Identifying Outliers?
===
class:small-code

- Cells that are unusually simple (or no expression)
- Cells that are unusually complex (doublets?)

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
plot(complexity.per.cell,log2(expression.per.cell+1))
abline(v=200, col="red")
abline(h=log2(4))
```

Identifying Outliers?
===
class:small-code

- Cells that are unusually simple (or no expression)
- Cells that are unusually complex (doublets?)

```{r, eval=TRUE, echo=FALSE, tidy=TRUE}
plot(complexity.per.cell,expression.per.cell+1)
abline(v=200, col="red")
abline(h=log2(4))
```

Identifying Noise?
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
#hist(gene.prevalence)
hist(log2(gene.prevalence))
abline(v=3, col="red")
```

Identifying Noise?
===
class:small-code

```{r, eval=TRUE, echo=FALSE, tidy=TRUE}
#hist(gene.prevalence)
hist(log2(gene.prevalence))
abline(v=3, col="red")
```

Filter Cells: Removing the Outlier Cells
===
class:small-code

```{r, eval=TRUE, echo=TRUE, tidy=TRUE}
pbmc.seurat <- Setup(pbmc.seurat,
                    min.cells=3, min.genes=200,
                    do.logNormalize=TRUE,
                    total.expr=1e4,
                    project="Tutorial")
```

Filter Genes: Averages are Less Useful
===
class:small-code

_**Say you were standing with one foot in the oven and one foot in an ice bucket. According to the percentage people, you should be perfectly comfortable.**_ --Bobby Bragan

Filter Genes: Averages are Less Useful
===
class:small-code

![average](images/prob_ave_expression.png)

Filter Genes: Using Prevalence
===
class:small-code

![occurence](images/prob_ave_expression2.png)

Filter Cells: Removing the Outlier Cells
===
class:small-code

- Outlier samples are not just measured by complexity
  - Percent Reads Mapping
  - Percent Mitochondrial Reads
  - Presence of marker genes
  - Intergenic/ exonic rate
  - 5' or 3' bias
  - other metadata ...
- Picard Tools and RNASeQC

Quality control for expression matrices
===

![puppies](images/corgis/puppies.jpg)

Seurat: Filtering on Metadata
===
class:small-code

- Data driven features
```{r, echo=TRUE, eval=TRUE}
# Get gene names
mito.gene.names <- grep("^MT-", rownames(pbmc.seurat@data), value=TRUE)
# Get TSS normalized mitochodrial counts
col.total.counts <- colSums(expm1(pbmc.seurat@data))
mito.percent.counts <- colSums(expm1(pbmc.seurat@data[mito.gene.names, ]))/col.total.counts
# Add to seurat object as a metadata
pbmc.seurat <- AddMetaData(pbmc.seurat, mito.percent.counts, "percent.mitochodrial")
```

Seurat: Filtering on Metadata
===
class:small-code

```{r, echo=TRUE, eval=FALSE}
VlnPlot(pbmc.seurat, c("nGene", "nUMI", "percent.mitochodrial"), nCol=3)
```

Seurat: Filtering on Metadata
===
class:small-code

```{r, echo=FALSE, eval=TRUE}
VlnPlot(pbmc.seurat, c("nGene", "nUMI", "percent.mitochodrial"), nCol=3)
```

Seurat: Filtering on Metadata
===
class:small-code

```{r, echo=TRUE, eval=TRUE}
GenePlot(pbmc.seurat, "nUMI", "percent.mitochodrial")
```

Seurat: Filtering on Metadata
===
class:small-code

```{r, echo=TRUE, eval=TRUE}
GenePlot(pbmc.seurat, "nUMI", "nGene")
```

Seurat: Filtering on Metadata
===
class:small-code

```{r, echo=TRUE, eval=TRUE}
dim(pbmc.seurat@data)
pbmc.seurat <- SubsetData(pbmc.seurat, subset.name = "nGene", accept.high = 2500)
pbmc.seurat <- SubsetData(pbmc.seurat, subset.name = "percent.mitochodrial", accept.high = 0.05)
dim(pbmc.seurat@data)
```

Saving as an R Object
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
save(pbmc.seurat, file = "~/seurat_tutorial.Robj")
```

Saving as Text Files
===

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
# Log-scale expression matrix
write.table(as.matrix(pbmc.seurat@data), file="seurat_data.txt")

# Study metadata
write.table(pbmc.seurat@data.info, file="seurat_metadata_tsne.txt")

# What is the metadata so far
head(pbmc.seurat@data.info)
```

Exploring QC with Scater
===
class:small-code

```{r, echo=TRUE, eval=TRUE}
# Load Data
data("sc_example_counts")
data("sc_example_cell_info")
```

Scater: What is the Data?
===
class:small-code

```{r, echo=TRUE, eval=TRUE}
corner(sc_example_counts)
```

Scater: What is the Info?
===
class:small-code

```{r, echo=TRUE, eval=TRUE}
corner(sc_example_cell_info)
```

Scater: Create Scater Object
===
class:small-code

```{r, echo=TRUE, eval=TRUE}
pd <- new("AnnotatedDataFrame", data=sc_example_cell_info)
rownames(pd) <- pd$Cell
example_sceset <- newSCESet(countData=sc_example_counts, phenoData=pd)
```

Scater: Quick Filter
===
class:small-code

```{r, echo=TRUE, eval=TRUE}
keep_feature <- rowSums(exprs(example_sceset)) > 0
example_sceset <- example_sceset[keep_feature,]
```

Scater: Calculare QC Metrics
===
class:small-code

```{r, echo=TRUE, eval=TRUE}
example_sceset <- calculateQCMetrics(example_sceset, feature_controls = 1:40)
```

Scater: Interactive Exploration
===
class:small-code

```{r, echo=TRUE, eval=FALSE}
scater_gui(example_sceset)
```

Scater: Plotting 2 Metadata with Counts
===
class:small-code

```{r, echo=TRUE, eval=FALSE}
plot(example_sceset, block1 = "Mutation_Status", block2 = "Treatment",
     colour_by = "Cell_Cycle", nfeatures = 300, exprs_values = "counts")
```

Scater: Plotting 2 Metadata with Counts
===
class:small-code

```{r, echo=FALSE, eval=TRUE}
plot(example_sceset, block1 = "Mutation_Status", block2 = "Treatment",
     colour_by = "Cell_Cycle", nfeatures = 300, exprs_values = "counts")
```

Scater: Plotting 2 Metadata with Gene Expression
===
class:small-code

```{r, echo=TRUE, eval=FALSE}
plotExpression(example_sceset, rownames(example_sceset)[1:6],
               x = "Mutation_Status", exprs_values = "exprs", colour = "Treatment")
```

Scater: Plotting 2 Metadata with Gene Expression
===
class:small-code

```{r, echo=FALSE, eval=TRUE}
plotExpression(example_sceset, rownames(example_sceset)[1:6],
               x = "Mutation_Status", exprs_values = "exprs", colour = "Treatment")
```

Scater: Plotting Expression Trends Given Metadata
===
class:small-code

```{r, echo=TRUE, eval=FALSE}
plotExpression(example_sceset, rownames(example_sceset)[7:12],
               x = "Mutation_Status", exprs_values = "counts", colour = "Cell_Cycle",
               show_median = TRUE, show_violin = FALSE,  xlab = "Mutation Status",
               log = TRUE)
```

Scater: Plotting Expression Trends Given Metadata
===
class:small-code

```{r, echo=FALSE, eval=TRUE}
plotExpression(example_sceset, rownames(example_sceset)[7:12],
               x = "Mutation_Status", exprs_values = "counts", colour = "Cell_Cycle",
               show_median = TRUE, show_violin = FALSE,  xlab = "Mutation Status",
               log = TRUE)
```

Scater: Plotting Technical Noise
===
class:small-code

```{r, echo=TRUE, eval=FALSE}
plotQC(example_sceset, type = "exprs-freq-vs-mean")
```

Scater: Plotting Technical Noise
===
class:small-code

```{r, echo=FALSE, eval=TRUE}
plotQC(example_sceset, type = "exprs-freq-vs-mean")
```

Normalization in Single Cell Data (TODO)
===

![fall](images/corgis/fall.jpg)

Why Not Use Population Based RNA-Seq Normalizations
===

Scone PPT
===



Using Scone for normalization (TODO)
===

Scone tutorial.

Section Summary
===

- Conservative Gene Filtering Based on Gene Level and Prevalance is often used.
- Cells are oftern filtered by complexity or certain metadata.
  - This can be confounded with biological cohort (caution!)
- Plotting metadata on projects of data is an important QC tool.
- Methodology is beginning to be created for normalization.

Good Morning!
===

![pillows](images/corgis/pillows.jpg)

Welcome to day 2!
===

- Using Seurat to plot genes
- Dimensionality reduction and plotting (PCA, tSNE).
- Plotting Samples.
- Batch effects and study confounding.
- Moving from clusters to populations of cells.
- Differential Expression (SCDE).
- Pathway analysis.
- Overview of available methodology.

Using Seurat to plot genes
===

![tea](images/corgis/tea.jpg)

Seurat: Viewing Specific Genes
===
class:small-code

- Check the identity of the cells!!!

```{r,eval=FALSE, echo=TRUE,tidy=TRUE,fig.align="center"}
VlnPlot(pbmc.seurat, c("GAPDH"))
```

Seurat: Viewing Specific Genes
===
class:small-code

- Check the identity of the cells!!!

```{r,eval=TRUE, echo=FALSE,tidy=TRUE,fig.align="center"}
VlnPlot(pbmc.seurat, c("GAPDH"))
```

Seurat: Plotting Genes vs Genes
===
class:small-code

```{r,eval=FALSE, echo=TRUE,tidy=TRUE,fig.align="center"}
# Plot a gene vs a gene
GenePlot(pbmc.seurat,"CD79A","CD79B",cex.use=1)
```

Seurat: Plotting Genes vs Genes
===
class:small-code

```{r,eval=TRUE, echo=FALSE,tidy=TRUE,fig.align="center"}
GenePlot(pbmc.seurat,"CD79A","CD79B",cex.use=1)
```

Dimensionality reduction and plotting (PCA, tSNE)
===

![outlier_corgi](images/corgis/outlier_corgi.jpg)

Dimensionality Reduction and Ordination
===

- Start with many measurements (high dimensional).
  - Want to reduce to a few features (lower-dimensional space).
- One way is to extract features based on capturing groups of variance.
- Another could be to preferentially select some of the current features.
  - We have already done this.
- We need this to plot the cells in 2D (or ordinate them).

PCA: in Quick Theory
===

- Eigenvectors of covariance matrix.
- Find orthogonal groups of variance.
- Given from most to least variance.
  - Components of variation.
  - Linear combinations explaining the variance.
  
---

![pca_describe](images/PCA_plot_02.gif)

PCA: in Quick Theory
===

http://setosa.io/ev/principal-component-analysis

PCA: in Practice
===

Things to be aware of.
- Data with different magnitudes will dominate.
  - Zero center and divided by SD.
  - (Standardized).
- Can be affected by outliers.

t-SNE: Nonlinear Dimensional Reduction
===

![tsne](images/cell_cycle_1.png)

t-SNE: Collapsing the Visualization to 2D
===

![tsne_collapsed](images/cell_cycle_collapse.png)

t-SNE: What and Why?
===

![tsne](images/tsne.png)

PCA and tSNE Together
===

Often tSNE is performed on PCA components
- Liberal number of components.
- Removes mild signal (assumption of noise).
- Faster, on less data but, hopefully the same signal.

Plotting Samples
===

![fancy](images/corgis/fancy.jpg)

PCA using Seurat
===
class:small-code

```{r, eval=TRUE, echo=TRUE,fig.align="center"}
# Select Highly variable genese
pbmc.seurat <- MeanVarPlot(pbmc.seurat,fxn.x=expMean,fxn.y=logVarDivMean,
                           x.low.cutoff=0.0125,x.high.cutoff=3,
                           y.cutoff=0.5,do.contour=FALSE)
pbmc.seurat <- PCA(pbmc.seurat,pc.genes=pbmc.seurat@var.genes,do.print=FALSE)
```

PCA using Seurat
===
class:small-code

```{r, eval=FALSE, echo=TRUE,tidy=TRUE,fig.align="center"}
# Calculate PCA projection
pbmc.seurat <- ProjectPCA(pbmc.seurat)
# Can plot top genes for top components
PrintPCA(pbmc.seurat,pcs.print=1:5,genes.print=5,use.full=TRUE)
```

PCA using Seurat
===
class:small-code

```{r, eval=TRUE, echo=TRUE,tidy=TRUE,fig.align="center"}
# Calculate PCA projection
pbmc.seurat <- ProjectPCA(pbmc.seurat)
```

PCA using Seurat
===
class:small-code

```{r, eval=TRUE, echo=FALSE,tidy=TRUE,fig.align="center"}
# Can plot top genes for top components
PrintPCA(pbmc.seurat,pcs.print=1:5,genes.print=5,use.full=TRUE)
```

PCA Visualizations
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
VizPCA(pbmc.seurat, 1:2)
```

PCA Visualizations
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
VizPCA(pbmc.seurat, 1:2)
```

PCA Visualizations
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
PCAPlot(pbmc.seurat, 1, 2)
```

PCA Visualizations
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
PCAPlot(pbmc.seurat, 1, 2)
```

PCA Visualizations
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
PCHeatmap(pbmc.seurat, pc.use=1, cells.use=100, do.balanced=TRUE)
```

PCA Visualizations
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
PCHeatmap(pbmc.seurat, pc.use=1, cells.use=100, do.balanced=TRUE)
```

Seurat: Choosing Components
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
# Time Intensive
# Jackstraw
# pbmc.seurat <- JackStraw(pbmc.seurat, num.replicate = 100, do.print = FALSE)
```

Seurat: Choosing Components
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
# Scree (elbow) plot
PCElbowPlot(pbmc.seurat)
```

Seurat: Choosing Components
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
# Tiem Efficient but more ad hoc
# Scree (elbow) plot
PCElbowPlot(pbmc.seurat)
```

Seurat: Choosing Components
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
# Time Efficient but more ad hoc
# Scree (elbow) plot
PCElbowPlot(pbmc.seurat)
```

Seurat: Store Clusters
===
class:small-code

```{r, eval=TRUE, echo=TRUE}
pbmc.seurat <- FindClusters(pbmc.seurat, pc.use = 1:10, resolution = 0.6, print.output = 0, save.SNN = TRUE)
```

Seurat: Run t-SNE
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
pbmc.seurat <- RunTSNE(pbmc.seurat, dims.use = 1:10, do.fast = TRUE)
TSNEPlot(pbmc.seurat)
```

Seurat: Run t-SNE
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
pbmc.seurat <- RunTSNE(pbmc.seurat, dims.use = 1:10, do.fast = TRUE)
TSNEPlot(pbmc.seurat)
```

Seurat: Side by side
===
class:small-code

**PCA**  
```{r, eval=TRUE, echo=FALSE}
PCAPlot(pbmc.seurat, 1, 2)
```

---

**t-SNE**  
```{r,eval=TRUE, echo=FALSE,tidy=TRUE}
TSNEPlot(pbmc.seurat)
```

Seurat: Plotting Genes Through Clusters
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
VlnPlot(pbmc.seurat, c("MS4A1","CD79A"))
```

Seurat: Plotting Genes Through Clusters
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
VlnPlot(pbmc.seurat, c("MS4A1","CD79A"))
```

Seurat: Plotting Genes on Clusters
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
FeaturePlot(pbmc.seurat, c("MS4A1","CD3E", "GNLY", "FCER1A"), cols.use = c("grey","blue"))
```

Seurat: Plotting Genes on Clusters
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
FeaturePlot(pbmc.seurat, c("MS4A1","CD3E", "GNLY", "FCER1A"), cols.use = c("grey","blue"))
```

Confirm Cell Identity
===
class:small-code

- Many cell populations have known expressing genes.
- Many assays use sorting.
- Could have contaminants or unexpected diversity.

Section Summary
===

- Dimensionality reduction help reduce data while *hopefully* keeping important signal.
  - tSNE on PCA is often used in analysis
- Created several types of plot often seen in publications.
  - Plotting genes (through subgroups).
  - Ordinating cells in tSNE space.
  - Heatmaps of genes associated with PC components.

Confounding by Design
===
![batch_effects](images/batch_effects_3.png)

QC the Clusters!
===
class:small-code

```{r,eval=FALSE, echo=TRUE,tidy=FALSE}
FeaturePlot(pbmc.seurat, c("nGene"), cols.use = c("grey","blue"))
```

QC the Clusters!
===
class:small-code

```{r,eval=TRUE, echo=FALSE,tidy=FALSE}
FeaturePlot(pbmc.seurat, c("nGene"), cols.use = c("grey","blue"))
```

QC the Clusters!
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=FALSE}
# Making Fake Data
fake.sites <- as.integer(pbmc.seurat@ident %in% c(5,2,8,7))
names(fake.sites) <- colnames(pbmc.seurat@data)
# Add metadata
pbmc.seurat <- AddMetaData(pbmc.seurat, fake.sites, "site")
# Plot feature
FeaturePlot(pbmc.seurat, c("site"), cols.use = c("green","orange"))
```

QC the Clusters!
===
class:small-code

```{r, eval=TRUE, echo=FALSE, tidy=FALSE}
# Making Fake Data
fake.sites <- as.integer(pbmc.seurat@ident %in% c(5,2,8,7))
names(fake.sites) <- colnames(pbmc.seurat@data)
# Add metadata
pbmc.seurat <- AddMetaData(pbmc.seurat, fake.sites, "site")
# Plot feature
FeaturePlot(pbmc.seurat, c("site"), cols.use = c("orange","purple"))
```

Differential Expression (SCDE)
===

![clump](images/corgis/corgi_clump.jpg)

Seurat: Getting your labels
===

```{r,eval=FALSE, echo=TRUE,tidy=FALSE}
cell.labels <- pbmc.seurat@ident
corner(cell.labels)
```

Seurat: Getting your labels
===

```{r,eval=TRUE, echo=FALSE,tidy=FALSE}
cell.labels <- pbmc.seurat@ident
corner(cell.labels)
```

SCDE: Single Cell Differential Expression
===

![scde_intro](images/scde_intro.png)

SCDE: in Quick Theory
===

For each group (ES or MEF).
- Genes are modeled to have two groups of counts.
  - Noisey area highly prone to dropout (Poisson distribution).
  - "Amplified" signal (Negative Binomial distribution).
- This makes the error model or how much one can trust counts.
- Pairwise within groups.

Differential Expression.
- Expected value * the probability of dropout in that cell for that expression level .

SCDE: Create Lables
===
class:small-code

```{r,eval=FALSE, echo=TRUE,tidy=FALSE}
library(scde) # Differential Expressions
data(es.mef.small)
## Setting up cells groups
data.groups <- rep(NA, ncol(es.mef.small))
data.groups[ grep("MEF", names(es.mef.small)) ] <- "MEF"
data.groups[ grep("ESC", names(es.mef.small)) ] <- "ESC"
data.groups <- factor(data.groups, levels = c("ESC","MEF"))
names(data.groups) <- colnames(es.mef.small)
table(data.groups)
```

SCDE: filter if not already
===
class:small-code

```{r, eval=FALSE, echo=TRUE,tidy=FALSE}
dim(es.mef.small)
cd <- clean.counts(es.mef.small, min.lib.size=1000, min.reads = 1, min.detected = 1)
dim(cd)
```

SCDE: filter if not already
===
class:small-code

```{r, eval=FALSE, echo=TRUE,tidy=FALSE}
## Calculate error models
## Time Intensive step
# o.ifm <- scde.error.models(counts=cd, groups= data.groups, n.cores=4,
#                           threshold.segmentation=TRUE, save.crossfit.plots=FALSE,
#                           save.model.plots=FALSE, verbose=1)
## Precomputed
data(o.ifm)
```

SCDE: Model Details
===
class:small-code

```{r, eval=FALSE, echo=TRUE,tidy=FALSE}
# Erorormodel coefficients (cells = rows)
# corr.a = slope of the correlated component fit
# Negative corr.a could be bad cells
# corr.b intercept of the correlated component fit
# corr.theta is NB over-dispersion
# fail.r background poisson rate
head(o.ifm)
```

SCDE: Model Details
===
class:small-code

```{r, eval=FALSE, echo=FALSE,tidy=FALSE}
head(o.ifm)
```

SCDE: Filter Out Poor Fits
===
class:small-code

```{r, eval=FALSE, echo=TRUE,tidy=FALSE}
dim(o.ifm)
valid.cells <- o.ifm$corr.a > 0
table(valid.cells)
o.ifm <- o.ifm[valid.cells, ]
dim(o.ifm)
```

SCDE: Estimate a Prior to Start
===
class:small-code

```{r, eval=FALSE, echo=TRUE,tidy=FALSE}
## Calculate the Prior (starting value)
o.prior <- scde.expression.prior(models=o.ifm, counts=cd, length.out=400, show.plot=FALSE)
```

SCDE: Perform Differential Tests
===

```{r, eval=FALSE, echo=TRUE, tidy=FALSE}
## Setting up cells groups
data.groups <- rep(NA, nrow(o.ifm))
data.groups[ grep("MEF", rownames(o.ifm)) ] <- "MEF"
data.groups[ grep("ESC", rownames(o.ifm)) ] <- "ESC"
data.groups <- factor(data.groups, levels = c("ESC","MEF"))
names(data.groups) <- row.names(o.ifm)

## Perform T-test like analysis
ediff <- scde.expression.difference(o.ifm, cd, o.prior, groups=data.groups, n.randomizations=100, n.cores=2, verbose=1)
```

Visualize Differentially Expressed Genes
===

- mle = log2 fold change (estimate) .
- ub and lb = upper and lower bound on mle .
- ce = log2 fold change (conservative estimate) .
- Z = Z-score .
- cZ = Z-score corrected for multiple hypothesis testing .

---

![scde_output](images/scde_output_2.png)

SCDE: Top Upregulated Genes
===

```{r, eval=FALSE, echo=TRUE, tidy=FALSE}
head(ediff[order(ediff$Z, decreasing  =  TRUE), ])
```

SCDE: Write Data to Text File
===

```{r, eval=FALSE, echo=TRUE, tidy=FALSE}
write.table(ediff[order(abs(ediff$Z), decreasing = TRUE), ],
            file = "./data/results.txt", row.names = TRUE, col.names = TRUE, sep = "\t", quote = FALSE)
```

SCDE: Plot a Gene
===

```{r, eval=FALSE, echo=TRUE, tidy=FALSE}
scde.test.gene.expression.difference("Tdh", models = o.ifm, counts = cd, prior = o.prior)
```

SCDE: Plot a Gene
===

```{r, eval=FALSE, echo=FALSE, tidy=FALSE}
scde.test.gene.expression.difference("Tdh", models = o.ifm, counts = cd, prior = o.prior)
```

SCDE: Interactive Exploration
===

```{r, eval=FALSE, echo=TRUE, tidy=FALSE}
scde.browse.diffexp(ediff, o.ifm, cd, o.prior, groups = groups, name = "diffexp1", port = 1299)
```

Pathway analysis
===

![saturation](images/corgis/corgi_saturation.jpg)

Pagoda
===

![pagoda_paper](images/pagoda_paper.png)

Pagoda: Overview Methodology
===

![pagoda_methodology](images/pagoda_methodology.png)

Pagoda: Load Data
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
data(pollen)
# Original genes and samples (count matrix)
dim(pollen)
# Filter poor cells
pollen.clean <- clean.counts(pollen)
# Cleaned matrix dimensions
dim(pollen.clean)
```

Pagoda: Create a Color Legend
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
name.keys <- gsub("^Hi_(.*)_.*", "\\1", colnames(pollen.clean))
name.keys
```

Pagoda: Create a Color Legend
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
l2cols <- c("coral4", "olivedrab3", "skyblue2", "slateblue3")[as.integer(factor(name.keys, levels = c("NPC", "GW16", "GW21", "GW21+3")))]
l2cols
```

Pagoda: Create Error Models
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
#knn <- knn.error.models(pollen.clean, k=ncol(pollen.clean)/4,
#                         n.cores=2, min.count.threshold=2,
#                         min.nonfailed=5, max.model.plots=10)
# Check number of cores
detectCores()
# Precomputed data
data(knn)
```

Pagoda: Normalize the Variance
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
varinfo <- pagoda.varnorm(knn, counts=pollen.clean,
                          trim=3/ncol(pollen.clean), max.adj.var=5,
                          n.cores=2, plot=TRUE)
# list top overdispersed genes
sort(varinfo$arv, decreasing = TRUE)[1:10]
# Control for complexity
varinfo <- pagoda.subtract.aspect(varinfo, colSums(pollen.clean[, rownames(knn)]>0))
```

Pagoda: Normalize the Variance
===
class:small-code

```{r, eval=FALSE, echo=FALSE, tidy=TRUE}
varinfo <- pagoda.varnorm(knn, counts=pollen.clean,
                          trim=3/ncol(pollen.clean), max.adj.var=5,
                          n.cores=2, plot=TRUE)
```


Pagoda: Normalize the Variance
===
class:small-code

```{r, eval=FALSE, echo=FALSE, tidy=TRUE}
# list top overdispersed genes
sort(varinfo$arv, decreasing = TRUE)[1:10]
# Control for complexity
varinfo <- pagoda.subtract.aspect(varinfo, colSums(pollen.clean[, rownames(knn)]>0))
```

Pagoda: Load Precomputed Gene Groups
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
library(org.Hs.eg.db)
# translate gene names to ids
ids <- unlist(lapply(mget(rownames(pollen.clean), org.Hs.egALIAS2EG, ifnotfound = NA), function(x) x[1]))
rids <- names(ids); names(rids) <- ids 
```


Pagoda: Load Precomputed Gene Groups
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
# convert GO lists from ids to gene names
gos.interest <- unique(c(ls(org.Hs.egGO2ALLEGS)[1:100],"GO:0022008","GO:0048699", "GO:0000280", "GO:0007067")) 
go.env <- lapply(mget(gos.interest, org.Hs.egGO2ALLEGS), function(x) as.character(na.omit(rids[x]))) 
go.env <- clean.gos(go.env) # remove GOs with too few or too many genes
go.env <- list2env(go.env) # convert to an environment
```

Pagoda: Know Gene Groups Overdispersion
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
pwpca <- pagoda.pathway.wPCA(varinfo, go.env, n.components = 1, n.cores = 2)
df <- pagoda.top.aspects(pwpca, return.table = TRUE, plot = TRUE, z.score = 1.96)
```


Pagoda: Know Gene Groups Overdispersion
===
class:small-code

```{r, eval=FALSE, echo=FALSE, tidy=TRUE}
pwpca <- pagoda.pathway.wPCA(varinfo, go.env, n.components = 1, n.cores = 2)
df <- pagoda.top.aspects(pwpca, return.table = TRUE, plot = TRUE, z.score = 1.96)
```

Pagoda: Know Gene Groups Overdispersion
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
head(df)
```

Pagoda: Novel Gene Group Overdispersion
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
clpca <- pagoda.gene.clusters(varinfo, trim = 7.1/ncol(varinfo$mat), n.clusters = 50, n.cores = 2, plot = TRUE)
```

Pagoda: Novel Gene Group Overdispersion
===
class:small-code

```{r, eval=FALSE, echo=FALSE, tidy=TRUE}
clpca <- pagoda.gene.clusters(varinfo, trim = 7.1/ncol(varinfo$mat), n.clusters = 50, n.cores = 2, plot = TRUE)
```

Pagoda: Novel Gene Group Overdispersion
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
df <- pagoda.top.aspects(pwpca, clpca, return.table = TRUE, plot = TRUE, z.score = 1.96)
```

Pagoda: Novel Gene Group Overdispersion
===
class:small-code

```{r, eval=FALSE, echo=FALSE, tidy=TRUE}
df <- pagoda.top.aspects(pwpca, clpca, return.table = TRUE, plot = TRUE, z.score = 1.96)
```

Pagoda: Novel Gene Group Overdispersion
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
head(df)
```

Pagoda: Cell Clustering
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
# Get full info on the top aspects
tam <- pagoda.top.aspects(pwpca, clpca, n.cells = NULL, z.score = qnorm(0.01/2, lower.tail = FALSE))
# Determine overall cell clustering
hc <- pagoda.cluster.cells(tam, varinfo)
tamr <- pagoda.reduce.loading.redundancy(tam, pwpca, clpca)
tamr2 <- pagoda.reduce.redundancy(tamr, distance.threshold = 0.9, plot = TRUE, cell.clustering = hc, labRow = NA, labCol = NA, box = TRUE, margins = c(0.5, 0.5), trim = 0)
col.cols <- rbind(groups = cutree(hc, 3))
```

Pagoda: Cell Clustering
===
class:small-code

```{r, eval=FALSE, echo=FALSE, tidy=TRUE}
# Get full info on the top aspects
tam <- pagoda.top.aspects(pwpca, clpca, n.cells = NULL, z.score = qnorm(0.01/2, lower.tail = FALSE))
# Determine overall cell clustering
hc <- pagoda.cluster.cells(tam, varinfo)
tamr <- pagoda.reduce.loading.redundancy(tam, pwpca, clpca)
tamr2 <- pagoda.reduce.redundancy(tamr, distance.threshold = 0.9, plot = TRUE, cell.clustering = hc, labRow = NA, labCol = NA, box = TRUE, margins = c(0.5, 0.5), trim = 0)
col.cols <- rbind(groups = cutree(hc, 3))
```

Pagoda: Visualize Clustering
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
pagoda.view.aspects(tamr2, cell.clustering = hc, box = TRUE, labCol = NA, margins = c(0.5, 20), col.cols = rbind(l2cols))
```

Pagoda: Interactive Clustering
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
# compile a browsable app, showing top three clusters with the top color bar
app <- make.pagoda.app(tamr2, tam, varinfo, go.env, pwpca, clpca, col.cols = col.cols, cell.clustering = hc, title = "NPCs")
# show app in the browser (port 1468)
show.app(app, "pollen", browse = TRUE, port = 1468) 
```

What Did We Miss?
===

- Seurat
  - Data imputation and Spatial Inference.
- SCDE
  - Batch Effect Correction.
- Pseudotemporal Analysis (time-series)
- So many more tools are emerging
-- https://github.com/seandavi/awesome-single-cell

Section Summary
===

- Generated groups of cells (labels) from subclusters.
- DE can be performed on cell subclusters.
  - Addresses the specific characteristics of the underlying data.
  - Is a t-test not an ANOVA
  - Can be time intensive.
- Pathway enrichment analysis can be performed using de novo and established gene groupings.

Thank You
===

- Aviv Regev
- Anindita Basu
- Asma Bankapur
- Brian Haas
- Chloe Villani
- Karthik Shekhar
- Matan Hofree
- Michel Cole
- Monika Kowalczyk
- Nir Yosef
- Regev Single Cell Working Group
- Today's Attendees

References
===

Please note this is a collection of many peoples ideas.
Included in the download is a references.txt to document sources, tutorials, software, and links to cute corgi pictures :-)

Questions?
===

![gradute corgi](images/corgis/graduate_corgi.jpg)

Notes: to Make a PDF
===
class:small-code

- Create a pdf file before you plot ( can plot multiple plots ).
- Close the plotting.

```{r,eval=FALSE,tidy=TRUE}
#pdf( "data/my_file.pdf", useDingbats = FALSE ) # Start pdf
#plot( 1:10, log(1:10 ) ) # plot in to the pdf file
#plot( seq(0,.9,.1), sin(0:9) ) # another plot for the pdf file
#dev.off() # Close pdf file ( very important )
```
